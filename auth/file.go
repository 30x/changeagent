package auth

import (
	"bufio"
	"errors"
	"os"
	"strings"
	"time"
)

/*
Load loads the specified file, replacing the contents of the current store
with whatever is in the file. The file must have been generated by the "htpasswd"
utility. An error will be returned if invalid file content is detected.
Only passwords encoded using "bcrypt" will work -- all others will effectively
be ignored.
*/
func (s *Store) Load(fileName string) error {
	f, err := os.Open(fileName)
	if err != nil {
		return err
	}
	defer f.Close()
	s.pwFile = fileName

	newUsers := make(map[string]*authUser)

	scan := bufio.NewScanner(f)
	for scan.Scan() {
		line := scan.Text()
		parsedLine := strings.Split(line, ":")
		if len(parsedLine) < 2 && line != "" {
			return errors.New("Invalid line in password file")
		}
		newUsers[parsedLine[0]] = &authUser{
			encoded: parsedLine[1],
		}
	}
	err = scan.Err()
	if err != nil {
		return err
	}

	s.latch.Lock()
	s.users = newUsers
	s.latch.Unlock()

	return nil
}

/*
Watch periodically checks the file loaded using "Load" and re-loads
it if it has changed. Reloading is done in a thread-safe way.
*/
func (s *Store) Watch(interval time.Duration) error {
	if s.pwFile == "" {
		return errors.New("Cannot watch password file because it was not loaded")
	}

	st, err := os.Stat(s.pwFile)
	if err != nil {
		return err
	}

	go func() {
		s.runWatcher(interval, st)
	}()
	return nil
}

func (s *Store) runWatcher(interval time.Duration, firstStat os.FileInfo) {

	tick := time.NewTicker(interval)
	lastStat := firstStat

	for {
		select {
		case <-tick.C:
			newStat, err := os.Stat(s.pwFile)
			if err == nil {
				if !lastStat.ModTime().Equal(newStat.ModTime()) {
					err = s.Load(s.pwFile)
					lastStat = newStat
				}
			}
		case <-s.stop:
			return
		}
	}
}
